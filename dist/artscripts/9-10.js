// Generated by CoffeeScript 1.12.6
(function() {
  var Chance, GenArt, SimplexNoise, _, argv, art, canvasModule, d3, d3Node, fs, path, seed;

  fs = require('fs');

  d3 = require('d3');

  _ = require('lodash');

  d3Node = require('d3-node');

  canvasModule = require('canvas-prebuilt');

  Chance = require('chance');

  SimplexNoise = require('simplex-noise');

  path = require('path');

  argv = require('yargs').alias('s', 'seed').argv;

  seed = Date.now();

  GenArt = require('./GenArt');

  art = new GenArt(seed);

  art.filename = path.basename(__filename, '.js') + '-' + seed;

  art.count = 24;

  art.numTicks = 92;

  art.bgColor = '#000';

  art.fillColor = 'black';

  art.simplex = new SimplexNoise;

  art.makeParticles = function() {
    console.log('Making ' + this.count + ' particles');
    this.data = d3.range(this.count).map((function(_this) {
      return function() {
        var c, offset, offsetAmount, x, y;
        offsetAmount = _this.chance.integer({
          min: 25,
          max: 500
        });
        offset = {};
        offset.y = _this.chance.floating({
          min: -offsetAmount,
          max: offsetAmount
        });
        x = _this.width / 2;
        y = (_this.height / 2) + offset.y;
        c = d3.hsl('white');
        c.opacity = _this.opacity;
        if (_this.chance.bool({
          likelihood: 1
        })) {
          x = 0;
        }
        if (_this.chance.bool({
          likelihood: 1
        })) {
          x = _this.width;
        }
        return {
          x: x,
          y: y,
          color: c.toString(),
          radius: _this.chance.integer({
            min: 5,
            max: 120
          }),
          shape: _this.chance.pickone(['circle', 'triangle', 'line'])
        };
      };
    })(this));
    return this.data;
  };

  art.tick = function() {
    var ticks;
    if (!this.ticks) {
      ticks = 0;
    }
    this.ticks++;
    return this.data.forEach((function(_this) {
      return function(d, i) {
        var arc, c, noiseValue;
        noiseValue = _this.simplex.noise2D(d.x, d.y);
        if (_this.chance.bool({
          likelihood: 50
        })) {
          d.radius *= noiseValue * 4.5;
        }
        if (_this.chance.bool({
          likelihood: 2
        })) {
          d.radius *= 2;
        }
        if (_this.chance.bool({
          likelihood: 2
        })) {
          d.radius *= 0.5;
        }
        if (_this.chance.bool({
          likelihood: 1
        })) {
          d.radius *= 4;
        }
        d.radius = _.clamp(d.radius, 1, _this.width);
        if (_this.chance.bool({
          likelihood: 40
        })) {
          d.y += _this.chance.floating({
            min: -4,
            max: 4
          } * noiseValue);
        }
        if (_this.chance.bool({
          likelihood: 8
        })) {
          d.y *= noiseValue * 6;
        }
        if (_this.chance.bool({
          likelihood: 8
        })) {
          d.y *= noiseValue * -6;
        }
        if (_this.chance.bool({
          likelihood: 70
        })) {
          d.y = _.clamp(d.y, 0, _this.height);
        }
        c = d3.hsl(d.color);
        c.opacity -= 0.01;
        d.color = c.toString();
        _this.ctx.beginPath();
        if (d.shape === 'circle') {
          arc = _this.chance.integer({
            min: 1,
            max: 2
          });
          _this.ctx.arc(d.x, d.y, d.radius, 0, arc * Math.PI);
        } else if (d.shape === 'triangle') {
          if (_this.chance.bool()) {
            _this.ctx.moveTo(d.x - d.radius, d.y);
          }
          if (_this.chance.bool()) {
            _this.ctx.lineTo(d.x + d.radius, d.y);
          }
          if (_this.chance.bool()) {
            _this.ctx.lineTo(d.x, d.y + (d.radius * 1.3));
          }
        } else if (d.shape === 'line') {
          if (_this.chance.bool()) {
            _this.ctx.moveTo(d.x, d.y - d.radius);
            _this.ctx.lineTo(d.x, d.y + d.radius);
          } else {
            _this.ctx.moveTo(d.x - d.radius, d.y);
            _this.ctx.lineTo(d.x + d.radius, d.y);
          }
        }
        _this.ctx.fillStyle = 'none';
        if (_this.chance.bool()) {
          _this.ctx.closePath();
        }
        _this.ctx.strokeStyle = d.color;
        return _this.ctx.stroke();
      };
    })(this));
  };

  if (require.main === module) {
    art.init({
      save: true
    });
  }

  module.exports = art;

}).call(this);
