// Generated by CoffeeScript 1.12.6
(function() {
  var Chance, GenArt, _, argv, art, clColors, d3, options, path, run, seed;

  path = require('path');

  d3 = require('d3');

  _ = require('lodash');

  argv = require('yargs').alias('s', 'seed').argv;

  seed = Date.now();

  clColors = require('nice-color-palettes/200');

  Chance = require('chance');

  GenArt = require('@ejfox/four-seventeen');

  options = {
    filename: path.basename(__filename, '.js') + '-' + seed,
    width: 720,
    height: 1280,
    count: 92,
    numTicks: 60,
    bgColor: 'white',
    fillColor: 'white',
    opacity: 1,
    randomizeCount: false,
    randomizeTicks: true,
    minRadius: 2,
    drawLinks: true,
    constrainEdges: false,
    colorChangeAmount: 2.5
  };

  art = new GenArt(seed, options);

  art.makeParticles = function() {
    var alphaDecay, centerOffsetX, centerOffsetY, charge, colorNum, i, j, ref, velocityDecay;
    console.log('Making ' + this.count + ' particles');
    colorNum = this.chance.integer({
      min: 1,
      max: 200
    });
    this.colors = clColors[colorNum];
    this.data = d3.range(this.count).map((function(_this) {
      return function(d, i) {
        var c, color, datum, offset, offsetAmount, x, y;
        offsetAmount = _this.chance.integer({
          min: 250,
          max: 900
        });
        offset = {};
        offset.x = _this.chance.floating({
          min: -offsetAmount,
          max: offsetAmount
        });
        offset.y = _this.chance.floating({
          min: -offsetAmount,
          max: offsetAmount
        });
        x = 0;
        y = (_this.height / 2) + offset.y;
        color = _this.chance.pickone(_this.colors);
        c = d3.hsl(color);
        c.opacity = _this.opacity;
        datum = {
          x: _this.width / 2,
          y: _this.height / 2,
          color: c.toString(),
          radius: _this.chance.integer({
            min: 2,
            max: 48
          }),
          opacity: _this.opacity
        };
        if (i % 25 >= 1) {
          datum.x = _this.width * 0.2;
          datum.y = _this.height / 2;
        }
        return datum;
      };
    })(this));
    this.links = d3.range(this.count * this.chance.floating({
      min: 0.5,
      max: 50
    })).map((function(_this) {
      return function() {
        return {
          source: _this.chance.integer({
            min: 0,
            max: _this.count - 1
          }),
          target: _this.chance.integer({
            min: 0,
            max: _this.count - 1
          })
        };
      };
    })(this));
    for (i = j = 0, ref = this.data.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      this.links.push({
        source: 1,
        target: i
      });
    }
    alphaDecay = this.chance.floating({
      min: 0.01,
      max: 0.25
    });
    velocityDecay = this.chance.floating({
      min: 0.01,
      max: 0.15
    });
    charge = -200;
    centerOffsetX = this.chance.floating({
      min: 0.35,
      max: 1.25
    });
    centerOffsetY = this.chance.floating({
      min: 0.35,
      max: 1.25
    });
    this.simulation = d3.forceSimulation(this.data).alphaDecay(alphaDecay).velocityDecay(velocityDecay).force('charge', d3.forceManyBody().strength(charge)).force('collide', d3.forceCollide(function(d) {
      return d.radius * 1.2;
    }).iterations(8)).force('link', d3.forceLink(this.links).distance(10).strength(1)).force('center', d3.forceCenter((this.width / 2) * centerOffsetX, (this.height / 2) * centerOffsetY));
    return this.data;
  };

  art.tick = function() {
    var j, tick, ticks;
    if (!this.ticks) {
      ticks = 0;
    }
    this.ticks++;
    for (tick = j = 0; j <= 20; tick = ++j) {
      this.simulation.tick();
    }
    if (this.drawLinks) {
      this.links.forEach((function(_this) {
        return function(d, i) {
          var c, linkopacity;
          if (d.i === 1) {
            linkopacity = _this.chance.floating({
              min: 0,
              max: 0.8
            });
            _this.ctx.beginPath();
            _this.ctx.moveTo(d.source.x, d.source.y);
            _this.ctx.lineTo(d.target.x, d.target.y);
            c = d3.hsl(d.target.color);
            c.opacity = 0.2;
            _this.ctx.strokeStyle = d.target.color;
            return _this.ctx.stroke();
          }
        };
      })(this));
    }
    return this.data.forEach((function(_this) {
      return function(d, i) {
        var c, colorChangeAmount, maxStep, noiseValue;
        noiseValue = _this.simplex.noise2D(d.x, d.y);
        maxStep = 1;
        if (_this.chance.bool({
          likelihood: 15
        })) {
          d.vx *= 2;
        } else if (_this.chance.bool({
          likelihood: 15
        })) {
          d.vx *= 2;
        }
        if (_this.chance.bool({
          likelihood: 25
        })) {
          d.x += _this.chance.floating({
            min: -maxStep,
            max: maxStep
          });
        }
        if (_this.chance.bool({
          likelihood: 25
        })) {
          d.y += _this.chance.floating({
            min: -maxStep,
            max: maxStep
          });
        }
        if (i === 1) {
          d.opacity = 0;
          if (_this.chance.bool({
            likelihood: 70
          })) {
            d.y += _this.chance.integer({
              min: -2,
              max: 7
            });
          }
        }
        if (_this.constrainEdges) {
          d.x = _.clamp(d.x, 0 + d.radius, _this.width - d.radius);
          d.y = _.clamp(d.y, 0 + d.radius, _this.height - d.radius);
        }
        d.radius -= ((noiseValue * 0.2) + (d.x / (_this.width * 16))) * 0.5;
        if (noiseValue > 0) {
          d.x += _this.chance.floating({
            min: -6,
            max: 6
          });
        } else {
          d.y += _this.chance.floating({
            min: -6,
            max: 6
          });
        }
        colorChangeAmount = (d.vy + d.vx) * 0.14;
        c = d3.hsl(d.color);
        c.h += colorChangeAmount * 0.5;
        if (noiseValue > 0) {
          c.s += colorChangeAmount * 0.01;
        } else {
          c.s -= colorChangeAmount * 0.01;
        }
        c.opacity = d.opacity;
        d.color = c.toString();
        _this.ctx.beginPath();
        _this.ctx.arc(d.x, d.y, d.radius, 0, 2 * Math.PI);
        _this.ctx.fillStyle = d.color;
        _this.ctx.strokeStyle = 'white';
        _this.ctx.lineWidth = 2;
        _this.ctx.fill();
        _this.ctx.stroke();
        return _this.ctx.closePath();
      };
    })(this));
  };

  run = function() {
    if (argv.seed) {
      seed = argv.seed;
    } else {
      seed = Date.now();
    }
    art.seed = seed;
    return art.init({
      save: true
    });
  };

  if (require.main === module) {
    run();
  }

  module.exports = art;

}).call(this);
