// Generated by CoffeeScript 1.12.6
(function() {
  var Chance, GenArt, _, argv, canvasModule, colorLovers, d3, d3Node, fs, path, run,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  fs = require('fs');

  d3 = require('d3');

  _ = require('lodash');

  d3Node = require('d3-node');

  canvasModule = require('canvas-prebuilt');

  Chance = require('chance');

  path = require('path');

  colorLovers = require('colourlovers');

  argv = require('yargs').alias('s', 'seed').argv;

  GenArt = (function() {
    function GenArt(seed) {
      this.tick = bind(this.tick, this);
      this.makeParticles = bind(this.makeParticles, this);
      this.init = bind(this.init, this);
      var d3n;
      console.log('Seed:', seed);
      d3n = new d3Node({
        canvasModule: canvasModule
      });
      this.seed = seed;
      this.chance = new Chance(this.seed);
      this.count = 24;
      this.numTicks = 35000;
      this.count = this.chance.integer({
        min: 1,
        max: this.count
      });
      this.numTicks = this.chance.integer({
        min: 1,
        max: this.numTicks
      });
      this.width = 1700;
      this.height = 1250;
      console.log('width', this.width, 'height', this.height);
      this.canvas = d3n.createCanvas(this.width, this.height);
      this.ctx = this.canvas.getContext('2d');
      if (this.chance.bool()) {
        this.ctx.globalCompositeOperation = this.chance.pickone(['multiply', 'lighten', 'difference']);
        this.tickOpacity = this.chance.integer({
          min: 1,
          max: 9
        }) * 0.1;
      } else {
        this.tickOpacity = 1;
      }
      this.bgColor = 'white';
      this.ctx.fillStyle = this.bgColor;
      this.ctx.fillRect(0, 0, this.width, this.height);
    }

    GenArt.prototype.init = function(options, callback) {
      if (options == null) {
        options = {};
      }
      return colorLovers.get('/palettes', {
        keywords: this.chance.pickone(['minimal', 'blue', 'heartbreak', 'darkness', 'burst'], {
          sortBy: 'DESC',
          numResults: 1,
          orderCol: this.chance.pickone(['dateCreated', 'score', 'name', 'numVotes', 'numViews'])
        })
      }, (function(_this) {
        return function(err, data) {
          var colors, rndColor;
          if (err) {
            console.log(err);
          }
          rndColor = _this.chance.integer({
            min: 1,
            max: data.length
          });
          if (data[0].colors) {
            colors = data[rndColor].colors;
          } else {
            colors = ['000', '1f73d6', '60042d'];
          }
          colors = colors.map(function(c) {
            return '#' + c;
          });
          if (_this.chance.bool({
            likelihood: 75
          })) {
            _this.bgColor = colors[0];
            _this.ctx.fillStyle = _this.bgColor;
            _this.ctx.fillRect(0, 0, _this.width, _this.height);
            colors.splice(1, 1);
          }
          console.log('colors ->', colors);
          _this.c10 = d3.scaleOrdinal().range(colors);
          _this.makeParticles();
          _this.tickTil(_this.numTicks);
          if (options.save) {
            _this.saveFile();
          }
          if (callback) {
            return callback();
          }
        };
      })(this));
    };

    GenArt.prototype.makeParticles = function() {
      var i;
      console.log('Making ' + this.count + ' particles');
      i = 0;
      this.data = d3.range(this.count).map((function(_this) {
        return function() {
          var direction, prclColor, x, y;
          i++;
          x = _this.width / 2;
          y = _this.height / 2;
          direction = _this.chance.pickone(['up', 'down', 'left', 'right']);
          prclColor = _this.c10(direction);
          return {
            x: x,
            y: y,
            color: _this.c10(i % 3),
            direction: direction,
            positions: [],
            radius: 150,
            stroke: _this.chance.bool({
              likelihood: 10
            })
          };
        };
      })(this));
      return this.data;
    };

    GenArt.prototype.tick = function() {
      var ticks;
      if (!this.ticks) {
        ticks = 0;
      }
      this.ticks++;
      return this.data.forEach((function(_this) {
        return function(d, i) {
          var c, dLikelies, hardOffset, moveUnit, randOffset;
          randOffset = 8;
          d.positions.push([d.x, d.y]);
          if (_.includes(d.positions, [d.x, d.y])) {
            console.log('prev position detected');
            d.direction = 'down';
            hardOffset = randOffset * 10;
            d.color = 'red';
            if (_this.chance.d100() > 50) {
              d.x -= _this.chance.integer({
                min: -hardOffset,
                max: hardOffset
              });
            } else {
              d.y -= _this.chance.integer({
                min: -hardOffset,
                max: hardOffset
              });
            }
          }
          dLikelies = d3.range(8).map(function() {
            return _this.chance.integer({
              min: 60,
              max: 90
            });
          });
          if (d.stroke) {
            moveUnit = 1;
          } else {
            moveUnit = _this.chance.integer({
              min: 1,
              max: 10
            });
          }
          if (d.direction === 'up') {
            if (d.y <= 0) {
              d.y = 0;
            }
            if (_this.chance.bool({
              likelihood: _.clamp(dLikelies[0] + 50, 0, 100)
            })) {
              d.y += moveUnit;
            }
            if (_this.chance.bool({
              likelihood: dLikelies[0]
            })) {
              d.x -= d.radius / 4;
            }
            if (_this.chance.bool({
              likelihood: dLikelies[1]
            })) {
              d.x += d.radius / 4;
            }
          } else if (d.direction === 'down') {
            if (d.y >= _this.height) {
              d.y = 0;
            }
            if (_this.chance.bool({
              likelihood: _.clamp(dLikelies[0] + 50, 0, 100)
            })) {
              d.y -= moveUnit;
            }
            if (_this.chance.bool({
              likelihood: dLikelies[2]
            })) {
              d.x -= d.radius / 4;
            }
            if (_this.chance.bool({
              likelihood: dLikelies[3]
            })) {
              d.x += d.radius / 4;
            }
          } else if (d.direction === 'left') {
            if (d.y <= 0) {
              d.y = _this.width;
            }
            if (_this.chance.bool({
              likelihood: _.clamp(dLikelies[0] + 50, 0, 100)
            })) {
              d.x -= moveUnit;
            }
            if (_this.chance.bool({
              likelihood: dLikelies[4]
            })) {
              d.y -= moveUnit;
            }
            if (_this.chance.bool({
              likelihood: dLikelies[5]
            })) {
              d.y += moveUnit;
            }
          } else if (d.direction === 'right') {
            if (d.y >= _this.width) {
              d.y = 0;
            }
            if (_this.chance.bool({
              likelihood: _.clamp(dLikelies[0] + 50, 0, 100)
            })) {
              d.x += moveUnit;
            }
            if (_this.chance.bool({
              likelihood: dLikelies[6]
            })) {
              d.y -= moveUnit;
            }
            if (_this.chance.bool({
              likelihood: dLikelies[7]
            })) {
              d.y += moveUnit;
            }
          }
          if (_this.chance.bool({
            likelihood: 10
          })) {
            d.direction = _this.chance.pickone(['up', 'down', 'left', 'right']);
          }
          if (_this.chance.bool({
            likelihood: 2
          })) {
            c = d3.hsl(d.color);
            c.h += _this.chance.integer({
              min: -5,
              max: 5
            });
            if (_this.chance.bool({
              likelihood: 15
            })) {
              c.s += _this.chance.integer({
                min: -45,
                max: 45
              });
            }
            d.color = c.toString();
          }
          d.radius = _.clamp(d.radius, 0, 95);
          if (_this.chance.bool({
            likelihood: _.clamp(_this.ticks / 10000),
            0: 0,
            80: 80
          })) {
            d.radius--;
          } else {
            if (_this.chance.bool({
              likelihood: 22
            })) {
              d.radius - (d.radius / 100);
            }
          }
          _this.ctx.beginPath();
          _this.ctx.arc(d.x, d.y, d.radius, 0, Math.PI * 2, true);
          if (d.stroke === true) {
            _this.ctx.fillStyle = 'none';
            _this.ctx.strokeStyle = d.color;
            return _this.ctx.stroke();
          } else {
            c = d3.hsl(d.color);
            c.opacity = _this.tickOpacity;
            d.color = c.toString();
            _this.ctx.fillStyle = d.color;
            return _this.ctx.fill();
          }
        };
      })(this));
    };

    GenArt.prototype.tickTil = function(count) {
      var j, ref;
      console.log('Ticking ' + this.data.length + ' particles ' + count + ' times');
      console.time('ticked for');
      for (j = 0, ref = count; 0 <= ref ? j <= ref : j >= ref; 0 <= ref ? j++ : j--) {
        this.tick();
      }
      return console.timeEnd('ticked for');
    };

    GenArt.prototype.saveFile = function(filename) {
      var fileOutput;
      if (!filename) {
        filename = path.basename(__filename, '.js') + '-' + this.seed;
      }
      fileOutput = './dist/' + filename + '.png';
      console.log('canvas output --> ' + fileOutput);
      return this.canvas.pngStream().pipe(fs.createWriteStream(fileOutput));
    };

    return GenArt;

  })();

  run = (function(_this) {
    return function() {
      var genart, seed;
      if (argv.seed) {
        seed = argv.seed;
      } else {
        seed = Date.now();
      }
      genart = new GenArt(seed);
      if (argv.count) {
        genart.count = argv.count;
      }
      if (argv.ticks) {
        genart.numTicks = argv.ticks;
      }
      return genart.init({
        save: true
      });
    };
  })(this);

  module.exports = GenArt;

  if (require.main === module) {
    run();
  }

}).call(this);
